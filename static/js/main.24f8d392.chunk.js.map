{"version":3,"sources":["ActionButton.js","AudioItem.js","RecordingState.js","RecordButton.js","AudioVisualizer.js","RecordingTimeManager.js","Utils.js","Annotation.js","App.js","serviceWorker.js","index.js"],"names":["styles","ActionButton","height","width","fontSize","backgroundColor","red","&:hover","color","fontWeight","marginTop","marginBottom","_this","this","classes","props","react_default","a","createElement","Button","className","onClick","onAnnotationButtonClicked","name","Component","withStyles","AudioItem","annotations","audioUrl","audioStream","Object","classCallCheck","hasMedia","stream","url","getAnnotationForTimestamp","timeStampMs","resultAnnotation","forEach","annotation","timestamp","totalDuration","RecordingStateActions","NONE","START","STOP","PAUSE","RESUME","TOKEN","token","RecordingState","status","Error","_status","RECORDING","PAUSED","OFF","STARTING","STOPPING","prevRecordingState","RecordingButton","RecordingButtonLabel","RecordButton","Fab","aria-label","recordingState","Stop_default","hasRecording","Replay_default","Mic_default","React","BAR_WIDTH_PX","REFRESH_INTERVAL_MS","CANVAS_MIN_WIDTH","Scroll","overflow","direction","margin","alignSelf","alignItems","Canvas","float","AudioVisualizer","possibleConstructorReturn","getPrototypeOf","call","componentDidUpdate","prevProps","prevState","audioArray","state","_draw","prevAudioItem","audioItem","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","smoothingTimeConstant","dataArray","Uint8Array","frequencyBinCount","source","createMediaStreamSource","connect","console","log","timerID","setInterval","_onRefreshVisualizer","disconnect","setState","componentWillUnmount","clearInterval","stop","getByteFrequencyData","values","i","length","newAudioArray","toConsumableArray","currentAnnotation","elapsedTimeMs","annotatedValues","slice","map","chunk","amplitude","annotated","splice","apply","concat","average","canvas","current","context","getContext","clearRect","index","barHeight","opacity","redColor","goldColor","fillStyle","fillRect","createRef","ref","RecordingTimeManager","onIntervalTick","interval","start","_recordingStartTimeMs","Date","now","_recordingInterval","_onIntervalTick","getElapsedTimeMs","_interval","pause","_currentRecordingPausedStartTime","_recordingPausedPeriods","resume","isStarted","nowMs","totalPausedTimeMs","keys","startTime","reduce","total","currentDuration","Utils","secondsToTimeString","totalSeconds","minutes","Math","floor","seconds","ActionItemAnnotation","_Annotation","inherits","Annotation","type","id","uuid","v4","App","textAlign","background","blueGrey","Duration","padding","Grid","AnnotationContainer","minHeight","AnnotationIcon","marginRight","AudioContainer","AudioPlayer","componentDidMount","script","document","src","async","body","appendChild","_ref","asyncToGenerator","regenerator_default","mark","_callee","recordingStateAction","wrap","_context","prev","next","compareToPrevious","t0","requestPermission","sent","_recordingTimeManager","_recorder","RecordRTCPromisesHandler","startRecording","abrupt","stopRecording","t1","getSeekableBlob","getBlob","t2","t3","seekableBlob","_audioAnalyzer","objectSpread","URL","createObjectURL","_x","_x2","arguments","_onMsIntervalTick","toggleRecording","_callee2","_context2","_callee3","_context3","navigator","mediaDevices","getUserMedia","video","audio","_this2","Container","container","item","src_RecordButton","bundle_default","controls","player","_audioPlayer","src_AudioVisualizer","element","justify","key","variant","disabled","audioEl","currentTime","play","PlayArrow_default","src_ActionButton","_onAnnotationButtonClicked","_this3","buttonName","actionItem","newAudioItem","Boolean","location","hostname","match","ReactDOM","render","src_App","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.24f8d392.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { withStyles } from \"@material-ui/styles\";\nimport Button from \"@material-ui/core/Button\";\n\nimport red from \"@material-ui/core/colors/red\";\n\nconst styles = {\n    ActionButton: {\n        height: \"60px\",\n        width: \"200px\",\n        fontSize: 24,\n        backgroundColor: red[\"500\"],\n        \"&:hover\": {\n            backgroundColor: red[\"200\"]\n        },\n        color: \"#fff\",\n        fontWeight: \"lighter\",\n        marginTop: \"20px\",\n        marginBottom: \"60px\"\n    }\n};\n\nclass ActionButton extends Component {\n    render() {\n        const { classes } = this.props;\n\n        return (\n            <Button\n                className={classes.ActionButton}\n                onClick={() => {\n                    this.props.onAnnotationButtonClicked(this.props.name);\n                }}\n            >\n                {this.props.name}\n            </Button>\n        );\n    }\n}\n\nexport default withStyles(styles)(ActionButton);\n","export default class AudioItem {\n    constructor(annotations, audioUrl, audioStream) {\n        this.annotations = annotations;\n        this.url = audioUrl;\n        this.stream = audioStream;\n    }\n\n    hasMedia = () => {\n        return (this.stream || this.url) != null;\n    };\n\n    getAnnotationForTimestamp = timeStampMs => {\n        let resultAnnotation;\n\n        if (this.annotations) {\n            this.annotations.forEach(annotation => {\n                if (\n                    timeStampMs <\n                        annotation.timestamp + annotation.totalDuration / 2 &&\n                    timeStampMs >\n                        annotation.timestamp - annotation.totalDuration / 2\n                ) {\n                    resultAnnotation = annotation;\n                }\n            });\n        }\n\n        return resultAnnotation;\n    };\n}\n","export const RecordingStateActions = {\n    NONE: \"NONE\",\n    START: \"START\",\n    STOP: \"STOP\",\n    PAUSE: \"PAUSE\",\n    RESUME: \"RESUME\"\n};\n\n// Make RecordingState's constructor effectively private by requiring this token\n// to construct, which is only available in this file.\nconst TOKEN = { token: \"unique recording state token\" };\n\nclass RecordingState {\n    constructor(token, status) {\n        if (token !== TOKEN) {\n            throw new Error(\n                \"RecordingState is an enum and should not be constructed directly; \" +\n                    \"please use an existing RecordingState.* declared in recording_state.es6.js\"\n            );\n        }\n\n        this._status = status;\n    }\n\n    isActive() {\n        return (\n            this === RecordingState.RECORDING || this === RecordingState.PAUSED\n        );\n    }\n\n    isRecording() {\n        return this === RecordingState.RECORDING;\n    }\n\n    isPaused() {\n        return this === RecordingState.PAUSED;\n    }\n\n    isOff() {\n        return this === RecordingState.OFF;\n    }\n\n    isStartingOrStopping() {\n        return (\n            this === RecordingState.STARTING || this === RecordingState.STOPPING\n        );\n    }\n\n    start() {\n        if (this === RecordingState.OFF) {\n            return RecordingState.STARTING;\n        } else {\n            return this;\n        }\n    }\n\n    stop() {\n        if (this === RecordingState.OFF) {\n            return RecordingState.OFF;\n        } else {\n            return RecordingState.STOPPING;\n        }\n    }\n\n    pause() {\n        return RecordingState.PAUSED;\n    }\n\n    resume() {\n        return RecordingState.RECORDING;\n    }\n\n    compareToPrevious(prevRecordingState) {\n        if (\n            this === RecordingState.STARTING &&\n            prevRecordingState === RecordingState.OFF\n        ) {\n            return RecordingStateActions.START;\n        } else if (\n            this === RecordingState.STOPPING &&\n            prevRecordingState !== RecordingState.STOPPING\n        ) {\n            return RecordingStateActions.STOP;\n        } else if (\n            this === RecordingState.RECORDING &&\n            prevRecordingState === RecordingState.PAUSED\n        ) {\n            return RecordingStateActions.RESUME;\n        } else if (\n            this === RecordingState.PAUSED &&\n            prevRecordingState === RecordingState.RECORDING\n        ) {\n            return RecordingStateActions.PAUSE;\n        }\n        return RecordingStateActions.NONE;\n    }\n}\n\nRecordingState.OFF = new RecordingState(TOKEN, \"OFF\");\nRecordingState.STARTING = new RecordingState(TOKEN, \"STARTING\");\nRecordingState.RECORDING = new RecordingState(TOKEN, \"RECORDING\");\nRecordingState.PAUSED = new RecordingState(TOKEN, \"PAUSED\");\nRecordingState.STOPPING = new RecordingState(TOKEN, \"STOPPING\");\n\nexport default RecordingState;\n","import React from \"react\";\nimport { withStyles } from \"@material-ui/styles\";\nimport Fab from \"@material-ui/core/Fab\";\nimport Mic from \"@material-ui/icons/Mic\";\nimport ReplayIcon from \"@material-ui/icons/Replay\";\nimport Stop from \"@material-ui/icons/Stop\";\nimport RecordingState from \"./RecordingState\";\n\nimport red from \"@material-ui/core/colors/red\";\n\nconst styles = {\n    RecordingButton: {\n        height: \"60px\",\n        width: \"60px\",\n        marginBottom: \"70px\",\n        backgroundColor: red[\"600\"],\n        \"&:hover\": {\n            backgroundColor: red[\"200\"]\n        },\n        color: \"#fff\"\n    },\n    RecordingButtonLabel: {\n        height: \"30px\",\n        width: \"30px\"\n    }\n};\n\nclass RecordButton extends React.Component {\n    render() {\n        const { classes } = this.props;\n\n        return (\n            <Fab\n                className={classes.RecordingButton}\n                aria-label=\"record\"\n                onClick={this.props.onClick}\n            >\n                {this.props.recordingState === RecordingState.RECORDING ? (\n                    <Stop className={classes.RecordingButtonLabel} />\n                ) : this.props.hasRecording ? (\n                    <ReplayIcon className={classes.RecordingButtonLabel} />\n                ) : (\n                    <Mic className={classes.RecordingButtonLabel} />\n                )}\n            </Fab>\n        );\n    }\n}\n\nexport default withStyles(styles)(RecordButton);\n","import React, { Component } from \"react\";\nimport RecordingState from \"./RecordingState\";\nimport { withStyles } from \"@material-ui/styles\";\nimport { red, amber } from \"@material-ui/core/colors/\";\n\nconst BAR_WIDTH_PX = 6;\nconst REFRESH_INTERVAL_MS = 60;\nconst CANVAS_MIN_WIDTH = 1000;\n\nconst styles = {\n    Scroll: {\n        width: CANVAS_MIN_WIDTH,\n        overflow: \"hidden\",\n        direction: \"rtl\",\n        margin: \"20px\",\n        alignSelf: \"center\",\n        alignItems: \"center\"\n    },\n    Canvas: {\n        float: \"right\",\n        height: \"300px\"\n    }\n};\n\nclass AudioVisualizer extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            audioArray: [],\n            width: 0\n        };\n\n        this.canvas = React.createRef();\n    }\n\n    componentDidUpdate = (prevProps, prevState) => {\n        if (prevState.audioArray !== this.state.audioArray) {\n            this._draw();\n        }\n        const prevAudioItem = prevProps.audioItem;\n        const audioItem = this.props.audioItem;\n        if (!prevAudioItem.hasMedia() && audioItem.hasMedia()) {\n            this.audioContext = new (window.AudioContext ||\n                window.webkitAudioContext)();\n\n            this.analyser = this.audioContext.createAnalyser();\n            this.analyser.smoothingTimeConstant = 0;\n            this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\n\n            if (audioItem.stream) {\n                this.source = this.audioContext.createMediaStreamSource(\n                    audioItem.stream\n                );\n                this.source.connect(this.analyser);\n            } else if (audioItem.url) {\n                console.log(\"HAVE URL\");\n            }\n\n            this.timerID = setInterval(() => {\n                if (this.props.recordingState === RecordingState.RECORDING) {\n                    this._onRefreshVisualizer();\n                }\n            }, REFRESH_INTERVAL_MS);\n        } else if (prevProps.audioStream && this.props.audioStream == null) {\n            this.analyser.disconnect();\n            this.source.disconnect();\n            this.setState({\n                audioArray: [],\n                width: CANVAS_MIN_WIDTH\n            });\n        }\n    };\n\n    componentWillUnmount = () => {\n        clearInterval(this.timerID);\n\n        this.analyser.disconnect();\n        this.source.disconnect();\n    };\n\n    stop = () => {\n        clearInterval(this.timerID);\n    };\n\n    _onRefreshVisualizer = () => {\n        this.analyser.getByteFrequencyData(this.dataArray);\n        let values = 0;\n        for (var i = 0; i < this.dataArray.length; i++) {\n            values += this.dataArray[i];\n        }\n\n        let newAudioArray = [...this.state.audioArray];\n        const currentAnnotation =\n            this.props.audioItem &&\n            this.props.audioItem.getAnnotationForTimestamp(\n                this.props.elapsedTimeMs\n            );\n        if (currentAnnotation != null) {\n            const annotatedValues = this.state.audioArray\n                .slice(\n                    -(currentAnnotation.totalDuration / 2 / REFRESH_INTERVAL_MS)\n                )\n                .map(\n                    chunk =>\n                        (chunk = {\n                            amplitude: chunk.amplitude,\n                            annotated: true,\n                            timestamp: chunk.elapsedTimeMs\n                        })\n                );\n\n            newAudioArray.splice(\n                newAudioArray.length - annotatedValues.length,\n                currentAnnotation.totalDuration / 2 / REFRESH_INTERVAL_MS,\n                ...annotatedValues\n            );\n        }\n\n        const average = values / this.dataArray.length;\n        this.setState({\n            width: this.state.audioArray.length * BAR_WIDTH_PX,\n            audioArray: [\n                ...newAudioArray,\n                {\n                    amplitude: average,\n                    annotated: currentAnnotation != null,\n                    timestamp: this.props.elapsedTimeMs\n                }\n            ]\n        });\n    };\n\n    _draw = () => {\n        const canvas = this.canvas.current;\n\n        const height = canvas.height;\n        const width = canvas.width;\n\n        const context = canvas.getContext(\"2d\");\n\n        context.clearRect(0, 0, width, height);\n\n        this.state.audioArray.forEach((chunk, index) => {\n            const barHeight = 5 + chunk.amplitude;\n            const opacity = 0.2 + barHeight / 50;\n            const redColor = \"rgba(244, 67, 54,\" + opacity + \")\";\n            const goldColor = \"rgba(255, 196, 0,\" + opacity + \")\";\n            context.fillStyle = chunk.annotated ? goldColor : redColor;\n\n            context.fillRect(\n                index * BAR_WIDTH_PX,\n                height / 2 - barHeight,\n                BAR_WIDTH_PX * 0.6,\n                barHeight * 2\n            );\n        });\n    };\n\n    render() {\n        const { classes } = this.props;\n        return (\n            <div className={classes.Scroll}>\n                <canvas\n                    className={classes.Canvas}\n                    width={this.state.width}\n                    ref={this.canvas}\n                />\n            </div>\n        );\n    }\n}\n\nexport default withStyles(styles)(AudioVisualizer);\n","export default class RecordingTimeManager {\n    constructor(onIntervalTick, interval) {\n        this._recordingInterval = null;\n        this._recordingStartTimeMs = null;\n        this._recordingPausedPeriods = {};\n        this._currentRecordingPausedStartTime = null;\n        this._onIntervalTick = onIntervalTick;\n        this._interval = interval;\n    }\n\n    setOnIntervalTick(onIntervalTick) {\n        this._onIntervalTick = onIntervalTick;\n    }\n\n    start = () => {\n        this._recordingStartTimeMs = Date.now();\n        this._recordingInterval = setInterval(() => {\n            this._onIntervalTick &&\n                this._onIntervalTick(this.getElapsedTimeMs());\n        }, this._interval && this._interval);\n    };\n\n    pause = () => {\n        this._currentRecordingPausedStartTime = Date.now();\n        this._recordingPausedPeriods[\n            this._currentRecordingPausedStartTime\n        ] = null;\n    };\n\n    resume = () => {\n        this._recordingPausedPeriods[\n            this._currentRecordingPausedStartTime\n        ] = Date.now();\n        this._currentRecordingPausedStartTime = null;\n    };\n\n    stop = () => {\n        clearInterval(this._recordingInterval);\n        this._recordingInterval = null;\n        this._recordingStartTimeMs = null;\n        this._recordingPausedPeriods = {};\n        this._currentRecordingPausedStartTime = null;\n    };\n\n    isStarted = () => this._recordingInterval;\n\n    getElapsedTimeMs = () => {\n        const nowMs = Date.now();\n        const totalPausedTimeMs = Object.keys(this._recordingPausedPeriods)\n            .map(startTime => {\n                let endTime = this._recordingPausedPeriods[startTime] || nowMs;\n                return endTime - startTime;\n            })\n            .reduce((total, currentDuration) => total + currentDuration, 0);\n        const elapsedRecordingTimeMs =\n            nowMs - this._recordingStartTimeMs - totalPausedTimeMs;\n        return elapsedRecordingTimeMs;\n    };\n}\n","const Utils = {\n    secondsToTimeString: totalSeconds => {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = Math.floor(totalSeconds % 60);\n        if (seconds < 10) {\n            seconds = \"0\" + seconds;\n        }\n        return `${minutes}:${seconds}`;\n    }\n};\n\nexport default Utils;\n","import uuid from \"uuid\";\nexport class Annotation {\n    constructor(type, timestamp, totalDuration) {\n        this.id = uuid.v4();\n        this.timestamp = timestamp;\n        this.totalDuration = totalDuration;\n        this.type = type;\n    }\n}\n\nexport class ActionItemAnnotation extends Annotation {\n    constructor(timestamp) {\n        super(\"Action Item\", timestamp, 10000);\n    }\n}\n","import React, { Component } from \"react\";\n\nimport { RecordRTCPromisesHandler, getSeekableBlob } from \"recordrtc\";\n\nimport ActionButton from \"./ActionButton\";\nimport AudioItem from \"./AudioItem\";\nimport RecordButton from \"./RecordButton\";\nimport AudioVisualizer from \"./AudioVisualizer\";\nimport RecordingTimeManager from \"./RecordingTimeManager\";\nimport RecordingState, { RecordingStateActions } from \"./RecordingState\";\nimport Utils from \"./Utils\";\nimport ReactAudioPlayer from \"react-audio-player\";\nimport { ActionItemAnnotation } from \"./Annotation\";\n\nimport blueGrey from \"@material-ui/core/colors/blueGrey\";\nimport { withStyles } from \"@material-ui/styles\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Container from \"@material-ui/core/Container\";\nimport Fab from \"@material-ui/core/Fab\";\n\nimport PlayArrow from \"@material-ui/icons/PlayArrow\";\n\nconst styles = {\n    App: {\n        height: \"100%\",\n        textAlign: \"center\",\n        background: blueGrey[800]\n    },\n    Duration: {\n        margin: 0,\n        padding: \"30px\",\n        textAlign: \"center\",\n        color: \"#fff\",\n        fontSize: 50,\n        fontWeight: \"lighter\"\n    },\n    Grid: {\n        height: \"100%\"\n    },\n    AnnotationContainer: {\n        minHeight: \"100px\"\n    },\n    Annotation: {\n        padding: \"8px\"\n    },\n    AnnotationIcon: {\n        height: \"30px\",\n        width: \"30px\",\n        marginRight: \"2px\"\n    },\n    AudioContainer: {\n        minHeight: \"340px\"\n    },\n    AudioPlayer: {\n        width: \"800px\",\n        marginTop: \"100px\",\n        marginBottom: \"40px\"\n    }\n};\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            recordingState: RecordingState.OFF,\n            audioItem: new AudioItem([], null, null),\n            elapsedTimeMs: 0\n        };\n\n        this._recordingTimeManager = new RecordingTimeManager(\n            this._onMsIntervalTick,\n            10\n        );\n    }\n\n    componentDidMount = () => {\n        const script = document.createElement(\"script\");\n        script.src = \"https://cdn.webrtc-experiment.com/EBML.js\";\n        script.async = true;\n        document.body.appendChild(script);\n    };\n\n    componentDidUpdate = async (prevProps, prevState) => {\n        const recordingStateAction = this.state.recordingState.compareToPrevious(\n            prevState.recordingState\n        );\n        switch (recordingStateAction) {\n            case RecordingStateActions.START:\n                let stream = await this.requestPermission();\n                this._recordingTimeManager.start();\n                this._recorder = new RecordRTCPromisesHandler(stream, {\n                    type: \"audio\"\n                });\n                await this._recorder.startRecording();\n                let annotations = this.state.audioItem.annotations;\n                this.setState({\n                    recordingState: RecordingState.RECORDING,\n                    audioItem: new AudioItem(annotations, null, stream)\n                });\n                break;\n            case RecordingStateActions.STOP:\n                await this._recorder.stopRecording();\n                getSeekableBlob(\n                    await this._recorder.getBlob(),\n                    seekableBlob => {\n                        this._recordingTimeManager.stop();\n                        this._audioAnalyzer.stop();\n                        this.setState({\n                            recordingState: RecordingState.OFF,\n                            audioItem: {\n                                ...this.state.audioItem,\n                                url: URL.createObjectURL(seekableBlob)\n                            },\n                            elapsedTimeMs: 0\n                        });\n                    }\n                );\n\n                break;\n            default:\n                break;\n        }\n    };\n\n    render() {\n        const { classes } = this.props;\n        return (\n            <Container className={classes.App}>\n                <Grid\n                    container\n                    direction=\"column\"\n                    alignItems=\"center\"\n                    className={classes.Grid}\n                >\n                    <Grid item>\n                        <h1 className={classes.Duration}>\n                            {Utils.secondsToTimeString(\n                                this.state.elapsedTimeMs / 1000\n                            )}\n                        </h1>\n                    </Grid>\n                    <Grid item>\n                        <RecordButton\n                            onClick={this.toggleRecording}\n                            recordingState={this.state.recordingState}\n                            hasRecording={\n                                this.state.audioItem &&\n                                this.state.audioItem.url != null\n                            }\n                        />\n                    </Grid>\n                    <Grid item className={classes.AudioContainer}>\n                        {this.state.audioItem && this.state.audioItem.url ? (\n                            <ReactAudioPlayer\n                                className={classes.AudioPlayer}\n                                src={this.state.audioItem.url}\n                                controls\n                                ref={player => {\n                                    if (player) {\n                                        this._audioPlayer = player;\n                                    }\n                                }}\n                            />\n                        ) : (\n                            <AudioVisualizer\n                                ref={element => {\n                                    if (element) {\n                                        this._audioAnalyzer = element;\n                                    }\n                                }}\n                                recordingState={this.state.recordingState}\n                                audioItem={this.state.audioItem}\n                                elapsedTimeMs={this.state.elapsedTimeMs}\n                            />\n                        )}\n                    </Grid>\n                    <Grid\n                        container\n                        direction=\"row\"\n                        justify=\"flex-start\"\n                        alignItems=\"center\"\n                        className={classes.AnnotationContainer}\n                    >\n                        {this.state.audioItem &&\n                            this.state.audioItem.annotations &&\n                            this.state.audioItem.annotations.map(annotation => (\n                                <Grid\n                                    item\n                                    className={classes.Annotation}\n                                    key={annotation.id}\n                                >\n                                    <Fab\n                                        variant=\"extended\"\n                                        disabled={!this.state.audioItem.url}\n                                        onClick={() => {\n                                            if (\n                                                this.state.audioItem.url !=\n                                                    null &&\n                                                this._audioPlayer != null\n                                            ) {\n                                                this._audioPlayer.audioEl.currentTime =\n                                                    (annotation.timestamp -\n                                                        annotation.totalDuration /\n                                                            2) /\n                                                    1000;\n\n                                                this._audioPlayer.audioEl.play();\n                                            }\n                                        }}\n                                    >\n                                        <PlayArrow\n                                            className={classes.AnnotationIcon}\n                                        />\n                                        {annotation.type}\n                                    </Fab>\n                                </Grid>\n                            ))}\n                    </Grid>\n                    <Grid item>\n                        <ActionButton\n                            name={\"Action Item\"}\n                            onAnnotationButtonClicked={this._onAnnotationButtonClicked()}\n                        />\n                    </Grid>\n                </Grid>\n            </Container>\n        );\n    }\n\n    _onMsIntervalTick = elapsedTimeMs => {\n        this.setState({\n            elapsedTimeMs: elapsedTimeMs\n        });\n    };\n\n    toggleRecording = async () => {\n        if (this.state.recordingState === RecordingState.RECORDING) {\n            this.setState({\n                recordingState: this.state.recordingState.stop()\n            });\n        } else if (this.state.recordingState === RecordingState.OFF) {\n            if (this.state.audioItem && this.state.audioItem.url == null) {\n                this.setState({\n                    recordingState: this.state.recordingState.start()\n                });\n            } else {\n                this.setState({\n                    audioItem: new AudioItem([], null, null)\n                });\n            }\n        }\n    };\n\n    requestPermission = async () => {\n        let stream = await navigator.mediaDevices.getUserMedia({\n            video: false,\n            audio: true\n        });\n\n        return stream;\n    };\n\n    _onAnnotationButtonClicked() {\n        return buttonName => {\n            if (buttonName === \"Action Item\") {\n                let actionItem;\n                if (this.state.recordingState === RecordingState.RECORDING) {\n                    actionItem = new ActionItemAnnotation(\n                        this.state.elapsedTimeMs\n                    );\n                } else {\n                    actionItem = new ActionItemAnnotation(\n                        this._audioPlayer.audioEl.currentTime * 1000\n                    );\n                }\n\n                const prevAudioItem = this.state.audioItem;\n                let newAudioItem = new AudioItem(\n                    [...prevAudioItem.annotations, actionItem],\n                    prevAudioItem.url,\n                    prevAudioItem.stream\n                );\n                this.setState({\n                    audioItem: newAudioItem\n                });\n            }\n        };\n    }\n}\n\nexport default withStyles(styles)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}